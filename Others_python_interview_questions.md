一、 Python 语言中对应其他编程语言的集合或是数组类型的数据结构类型有哪些? 各自的特点是? 列举他们的初始化,增删改的方法

答案:

1) 列表 list, 赋值后可以再修改  
赋值方法: var = list(), var = [], var = [值, ] 任意一种都对  
追加: var.append() , var.extend(), var.insert 都对  
删除: var.remove() , delete(var[下标]) 都对  
修改: var[下标] = 值, var = [新值的序列] 都对  

2) 元组 tuple, 一经赋值不可再修改  
赋值方法: var = tuple(), var = (), var = (值, ) 任意一种都对  
赋值后不可修改, 故没有增删改方法


二、 Python中断言和异常捕获的语句形式, 写一个示例代码

断言:

```
user_var = 5
assert(user_var=7)
```

异常捕获:

```
try:
    任意表达式
exception 异常类型:
    异常处理操作
else:
    未异常的操作
finally:
    无论是否异常都要执行的操作
```

备注: ```else``` 子句和 ```finally``` 由于不是必须的, 所以即使不写出也不算错.

三、 Python2 和 Python3 在字符编码方面, 也包括对中文处理, 最显著的变化是什么?

python2 中使用ascii编码，python3 中使用utf-8编码  
python2 中unicode表示字符串序列，str表示字节序列; python3 中str表示字符串序列，byte表示字节序列  
python2 中为正常显示中文，引入coding声明，python3 中不需要

四、请写分别一个示例语句, 演示在Python 中的循环; 另外分别写一个示例语句, 演示Python循环中, 中止本轮循环继续下一轮循环, 以及跳出循环的例子.

while 语句

```
while 表达式
    执行操作
```

for 语句

```
for 表达式 / 迭代器
    执行操作
```

中止本轮循环继续下一轮循环, 形式不限, continue关键字用法正确即可

```
for 表达式 / 迭代器
    if 表达式:
        continue
```

跳出循环, 形式不限, break关键字用法正确即可

```
for 表达式 / 迭代器
    if 表达式:
        break
```

五、请列举Python语法中支持的注释符号格式

```
# 井号

'''
三个连续的单引号
'''

"""
三个连续的双引号
"""

```

六、正则表达式匹配中，（.*）和（.*?）匹配区别？

```
（.*）是贪婪匹配，会把满足正则的尽可能多的往后匹配

（.*?）是非贪婪匹配，会把满足正则的尽可能少匹配
```

七、在Python浮点数处理中, 为保留指定位数,
有 ```.format()```, ```print('%.2f' % num)```, ```round()```, ```decimal``` 几种内置函数可用.
请用一两句话概括他们的特点, 并指出在数值敏感型的应用场景下, 精度最高的是哪种方法?

```.format()``` 字符串处理, 自定义填充字符, 格式化文本, 四舍五入原则  
```print('%.2f' % num)``` 字符串处理, 自定义填充字符, 格式化文本, 四舍五入原则  
```round()``` 数值处理, 四舍五入原则  
```decimal``` 数值处理, 精度最高, 四舍五入原则

八、Linux系统上, 有日志文件 /var/log/messages, 现在需要用Python 对其中的内容进行解析, 请使用示例代码演示你会使用的方法? 
第二问, 假设这个文件大小非常之大, 从节省不必要的资源开销的角度出发, 最理想的方法应当是如何?

参考答案, 最理想的几种方式是

```
# 以文件句柄形式打开, 以迭代器形式遍历
file_handler = open(file_name, 'rb')
for line in file_handler:
    print(line.decode('utf-8')) # 'utf-8'只是指定编码示例, 本题不强求


# 使用read(), 但限定大小
with open(file_name,encoding='utf-8') as file_obj:
    content = file_obj.read(6) #指定读取6个字符
    content = file_obj.read(6) #从上次读取到的位置开始
    print(content)
```

应答者如果只能回答出 ```read()```, ```readlines()```, ```enumerate()```, 但未给出限定一次读取大小的操作, 则不算掌握.  
重点在于考察应答者是否知晓一次性载入全部文件可能导致内存不够的问题, 可能是文件总体过大, 也可能单行文本内容过长.


九、在函数传参时, 我们比较容易见到的用法 ```* args```，```** kwargs``` , 请尝试简要描述他们的用法.

当我们不确定将多少个参数传递给函数，或者我们想要将存储的列表或参数元组传递给函数时，我们使用```*args```  
当我们不知道将多少关键字参数传递给函数时使用```** kwargs```，或者它可以用于将字典的值作为关键字参数传递。  
标识符args和kwargs是一个约定，你也可以使用```* bob```和```** billy```。

十、Python是如何管理内存的?

Python中的内存管理由Python私有堆空间管理。所有Python对象和数据结构都位于私有堆中。程序员无权访问此私有堆。python解释器负责处理这个问题。

Python对象的堆空间分配由Python的内存管理器完成。核心API提供了一些程序员编写代码的工具。

Python还有一个内置的垃圾收集器，它可以回收所有未使用的内存，并使其可用于堆空间。

十一、Python中的GIL是什么, 其优劣势分别是什么?

GIL 全称 Global Interpreter Lock，即全局解释器锁

在 CPython 解释器中，全局解释锁 GIL 是在于执行 Python 字节码时，为了保护访问 Python 对象而阻止多个线程执行的一把互斥锁。这把锁的存在主要是因为 CPython 
解释器的内存管理不是线程安全的。然而直到今天 GIL 依旧存在，现在的很多功能已经习惯于依赖它作为执行的保证。  
GIL 是存在于 CPython 解释器中的，属于解释器层级，而并非属于 Python 的语言特性。  
GIL 是为了让解释器在执行 Python 代码时，同一时刻只有一个线程在运行，以此保证内存管理是安全的  
历史原因，现在很多 Python 项目已经习惯依赖 GIL（开发者认为 Python 就是线程安全的，写代码时对共享资源的访问不会加锁）  

劣势: 由于GIL的存在, Python的线程要获得运行权, 需要先申请到GIL锁, 而GIL互斥锁的特性就决定任意一个特定时刻,只有一个线程能被执行, 因此Python的线程无法利用CPU的多个逻辑处理器的计算能力.

十二、在需要利用CPU多核心并行计算能力时, Python中有哪些类库可以实现, 并简要描述各自的特点, 在编程中有什么技术特性需要注意?

使用python的 ```multiprocessing``` 使用多进程, 可以利用多核心.  
应答者可以在答案中提到 ```协程``` ```gevent```, 但答案中需要清晰协程本身也是线程的一种  
协程相比线程的优势在于节省了线程切换产生的上下文开销  
不借助 ```multiprocessing``` 的 ```协程``` ```gevent``` 依然无法摆脱 GIL 的限制

编程中需要注意的技术特性:  
使用多进程需要自己实现 互斥资源的管理 和 进程间通信

十三、在现有的Linux系统上(以Linux内核2.x和3.x为标志), 部分系统的基础软件功能是以 Python2 为基础实现的, 
而以Python3 编写的程序功能要在此背景下, 既不影响原有系统功能的运行, 又要保证自身的正常运行.
通常可行的做法有哪些?

1) Python3 解释器被编译安装命名 ```python3```, 而不占用系统原有的 ```python```
2) 使用python的 ```virtualenv``` ```Virtualenvwrapper``` ```venv``` 等方式创建虚拟环境
3) 将python代码使用 ```pyinstaller``` 等类库打包成可执行程序
